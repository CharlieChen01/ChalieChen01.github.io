[{"content":"In Solidity, the indexed modifier is used to declare parameters in events (event) and indicates that the value of the parameter should be indexed. The purpose of the indexed modifier is to create a searchable index for event parameters, allowing for more efficient filtering and retrieval of events. When a parameter is declared as indexed, the Solidity compiler creates an index for that parameter in the event log.\nHere are some key points about the indexed attribute in Solidity events:\nUsing indexed in Event Definitions: You can add the indexed attribute to parameters in your event definitions. Up to three parameters can be indexed. For example: event Transfer(address indexed _from, address indexed _to, uint indexed _amount); In the example above, both _from and _to parameters are set as indexed, meaning we can listen for these events and filter by these two parameters’ values using Web3.js or Ethers.js.\nFiltering Events: With indexed parameters, we can filter events more precisely. Here are some examples:\nFiltering events where a certain address is the sender: let filter = this.contract_instance.filters.Transfer(this.active_wallet.address, null, null); this.contract_instance.on(filter, (from, to, value, event) =\u0026gt; { console.log(\u0026#34;Listening to Ether transfer events:\u0026#34;); console.log(`from: ${from} to: ${to} value: ${value}`); }); Filtering events where a certain address is the receiver: let filter = this.contract_instance.filters.Transfer(null, this.active_wallet.address, null); this.contract_instance.on(filter, (from, to, value, event) =\u0026gt; { console.log(\u0026#34;Listening to Ether transfer events:\u0026#34;); console.log(`from: ${from} to: ${to} value: ${value}`); }); Filtering events with a specific amount (note the value is in hexadecimal): // Filter for events with value of 100 let filter = this.contract_instance.filters.Transfer(null, null, \u0026#34;0x64\u0026#34;); // Filter for events with values in an array let filter = this.contract_instance.filters.Transfer(null, null, [\u0026#34;0x63\u0026#34;, \u0026#34;0x64\u0026#34;, \u0026#34;0x65\u0026#34;]); this.contract_instance.on(filter, (from, to, value, event) =\u0026gt; { console.log(\u0026#34;Listening to Ether transfer events:\u0026#34;); console.log(`from: ${from} to: ${to} value: ${value}`); }); In summary, the indexed attribute allows us to handle event parameters in Solidity more effectively, enhancing the flexibility and usability of events.\n在 Solidity 中，indexed 修饰符用于声明事件（event）中的参数，并指示将该参数的值进行索引。indexed 修饰符的作用是为事件参数创建一个可搜索的索引，以便更高效地过滤和检索事件。当一个参数被声明为 indexed 时，Solidity 编译器会在事件的日志中为该参数创建一个索引。\n具体来说，indexed 属性在 Solidity 事件中非常重要，因为它允许我们在事件参数上进行值过滤。以下是一些关于 indexed 属性的重要信息：\n定义事件时使用 indexed 属性： 你可以在事件定义中的参数上增加 indexed 属性。最多可以对三个参数增加这样的属性。例如： event Transfer(address indexed _from, address indexed _to, uint indexed amount); 在上面的示例中，_from 和 _to 参数都被设置为 indexed，这意味着我们可以在 Web3.js 或 Ethers.js 中通过对这两个参数进行值过滤来监听相应的事件。\n过滤事件： 通过使用 indexed 参数，我们可以更精确地过滤事件。以下是一些示例：\n过滤某个地址为发送者的事件： let filter = this.contract_instance.filters.Transfer(this.active_wallet.address, null, null); this.contract_instance.on(filter, (from, to, value, event) =\u0026gt; { console.log(\u0026#34;监听发送以太坊事件:\u0026#34;); console.log(`from: ${from} + to: ${to} + value: ${value}`); }); 过滤某个地址为接收者的事件： let filter = this.contract_instance.filters.Transfer(null, this.active_wallet.address, null); this.contract_instance.on(filter, (from, to, value, event) =\u0026gt; { console.log(\u0026#34;监听发送以太坊事件:\u0026#34;); console.log(`from: ${from} + to: ${to} + value: ${value}`); }); 过滤指定数量的事件（注意参数值是十六进制）： // 过滤 value 为 100 的事件 let filter = this.contract_instance.filters.Transfer(null, null, \u0026#34;0x100\u0026#34;); // 过滤 value 为数组中值的事件 let filter = this.contract_instance.filters.Transfer(null, null, [\u0026#34;0x99\u0026#34;, \u0026#34;0x100\u0026#34;, \u0026#34;0x101\u0026#34;]); this.contract_instance.on(filter, (from, to, value, event) =\u0026gt; { console.log(\u0026#34;监听发送以太坊事件:\u0026#34;); console.log(`from: ${from} + to: ${to} + value: ${value}`); }); 总之，indexed 属性使我们能够更有效地处理 Solidity 中的事件参数，从而提高了事件的灵活性和可用性。\n","permalink":"http://localhost:1313/posts/the-solidity-indexed-modifier/","summary":"In Solidity, the indexed modifier is used to declare parameters in events (event) and indicates that the value of the parameter should be indexed. The purpose of the indexed modifier is to create a searchable index for event parameters, allowing for more efficient filtering and retrieval of events. When a parameter is declared as indexed, the Solidity compiler creates an index for that parameter in the event log.\nHere are some key points about the indexed attribute in Solidity events:","title":"The Solidity Indexed Modifier"},{"content":"To understand the differences between ERC20 and ERC721, let’s delve into their characteristics:\nFungibility vs. Non-Fungibility:\nERC20 tokens are fungible. This means that each token is identical and interchangeable with any other token of the same type. For example, if you have an ERC20 token representing a cryptocurrency, one unit of that token is equivalent to any other unit of the same token. ERC721 tokens, on the other hand, are non-fungible. Each token is unique and cannot be divided. These tokens represent ownership of specific, individual items. For instance, collectibles, game assets, and real estate can be represented using ERC721 tokens. Functionality:\nERC20 tokens offer basic functions such as transfers and balance checks. They are commonly used for cryptocurrencies, utility tokens, and project ownership. ERC721 tokens provide additional features beyond basic transfers. These features include owner tracking and metadata storage. They are primarily used for representing ownership and trading of unique digital assets. In summary, ERC20 tokens are like money—fungible and interchangeable—while ERC721 tokens are non-fungible and represent unique, indivisible assets. Understanding these differences is crucial when working with Ethereum tokens!\n要了解 ERC20 和 ERC721 的区别，让我们深入了解它们的特点：\n可互换性与不可互换性： ERC20 代币是可互换的。这意味着每个代币都是相同的，可以与任何其他同类型代币互换。例如，如果您有一个代表加密货币的 ERC20 代币，那么该代币的一个单位就等同于相同代币的任何其他单位。 另一方面，ERC721 代币是不可兑换的。每个代币都是独一无二的，不可分割。这些代币代表对特定、个别物品的所有权。例如，收藏品、游戏资产和房地产都可以用 ERC721 代币来表示12。\n功能性： ERC20代币提供转账和余额查询等基本功能。它们通常用于加密货币、实用代币和项目所有权。 ERC721代币提供基本转账之外的其他功能。这些功能包括所有者跟踪和元数据存储。它们主要用于代表独特数字资产的所有权和交易。\n总之，ERC20 代币就像货币\u0026ndash;可流通、可互换\u0026ndash;而 ERC721 代币不可流通，代表独一无二、不可分割的资产5。在使用以太坊代币时，了解这些差异至关重要！\n","permalink":"http://localhost:1313/posts/differences-between-erc-20-and-erc-721/","summary":"To understand the differences between ERC20 and ERC721, let’s delve into their characteristics:\nFungibility vs. Non-Fungibility:\nERC20 tokens are fungible. This means that each token is identical and interchangeable with any other token of the same type. For example, if you have an ERC20 token representing a cryptocurrency, one unit of that token is equivalent to any other unit of the same token. ERC721 tokens, on the other hand, are non-fungible.","title":"Differences Between ERC 20 and ERC 721"},{"content":"How to implement Proof of Work (PoW) and Proof of Stake (PoS) algorithms for blockchain in Go? Here are the steps:\nDefine the block structure: Let’s start by creating a new Go project and importing all the necessary packages to build our blockchain. Create a file named blockchain.go and import all the dependencies you need by saving the following code in it. First, you need to define the data structure of the block, including the Index, Timestamp, PrevHash, Data, Nonce, Difficulty, and Hash. The Hash field will store the hash value of the block, while the PrevHash field points to the hash of the previous block in the blockchain.\npackage blockchain\rimport (\r\u0026#34;bytes\u0026#34;\r\u0026#34;crypto/sha256\u0026#34;\r\u0026#34;encoding/hex\u0026#34;\r\u0026#34;strconv\u0026#34;\r\u0026#34;time\u0026#34;\r)\r// Block represents a block in the blockchain.\rtype Block struct {\rIndex int\rTimestamp int64\rPrevHash string\rData string\rNonce int\rDifficulty int\rHash string\r} Create a hash function: The security of the blockchain depends on the hash function. You need to create a function to calculate the hash value of a block, usually using the SHA-256 algorithm.\nfunc calculateHash(block Block) string {\rrecord := strconv.Itoa(block.Index) + strconv.FormatInt(block.Timestamp, 10) +\rblock.PrevHash + block.Data + strconv.Itoa(block.Nonce)\rhash := sha256.Sum256([]byte(record))\rreturn hex.EncodeToString(hash[:])\r} Implement the PoW algorithm: Proof-of-Work algorithms require miners to solve a mathematical puzzle to prove that they put in the work. This usually involves adjusting a block\u0026rsquo;s value until its hash satisfies a specific condition (e.g., starts with a certain number of zeros).\nCreating the POW Genesis Block The genesis block is the first block in the blockchain and serves as the starting point. It has a fixed set of values and does not refer to any previous block. Let’s create a function to generate the genesis block in a file named pow_genesis.go package blockchain\rimport (\r\u0026#34;time\u0026#34;\r)\r// createGenesisBlock creates the first block in the blockchain (genesis block).\rfunc CreateGenesisBlock(difficulty int) Block {\rtimestamp := time.Now().Unix()\rgenesisBlock := Block{\rIndex: 0,\rTimestamp: timestamp,\rPrevHash: \u0026#34;0\u0026#34;,\rData: \u0026#34;Genesis Block\u0026#34;,\rNonce: 0,\rDifficulty: difficulty,\r}\rgenesisBlock.Hash = CalculateHash(genesisBlock)\rreturn genesisBlock\r} The CreateGenesisBlock function generates the genesis block with a given difficulty level. It sets the PrevHash value to \u0026ldquo;0\u0026rdquo; and calculates the hash using the CalculateHash function.\nGenerating a New Block with Proof of Work Next, we’ll implement the GenerateNewBlockWithPoW function, which generates a new block in the blockchain based on the previous block and the provided data using the Proof of Work algorithm. Open a new file named pow.go and include the following code: package blockchain\rimport (\r\u0026#34;math\u0026#34;\r\u0026#34;math/big\u0026#34;\r\u0026#34;time\u0026#34;\r)\r// GenerateNewBlockWithPoW generates a new block in the blockchain using Proof of Work.\rfunc GenerateNewBlockWithPoW(prevBlock Block, data string, difficulty int) Block {\rvar nonce int\rtimestamp := time.Now().Unix()\rnewBlock := Block{\rIndex: prevBlock.Index + 1,\rTimestamp: timestamp,\rPrevHash: prevBlock.Hash,\rData: data,\rNonce: 0,\rDifficulty: difficulty,\r}\r// Perform the proof of work\rtarget := big.NewInt(1)\rtarget.Lsh(target, uint(256-difficulty))\rfor nonce \u0026lt; math.MaxInt64 {\rnewBlock.Nonce = nonce\rhash := CalculateHash(newBlock)\rhashInt := new(big.Int)\rhashInt.SetString(hash, 16)\rif hashInt.Cmp(target) == -1 {\rnewBlock.Hash = hash\rbreak\r} else {\rnonce++\r}\r}\rreturn newBlock\r} The GenerateNewBlockWithPoW function takes the previous block, new data, and the desired difficulty level as parameters. It initializes a new block with the appropriate values and performs the proof of work calculation. The target value represents the threshold that the block\u0026rsquo;s hash must meet to satisfy the difficulty level. The function continues to increment the Nonce until a suitable hash is found.\nImplementing PoS algorithms: Proof-of-Stake algorithms are an alternative consensus mechanism that selects nodes to create new blocks based on the amount of currency a user holds and how long they have held it.\nCreating the Genesis Block package blockchain\rimport (\r\u0026#34;time\u0026#34;\r)\r// CreateGenesisBlockForPoS creates the first block in the blockchain (genesis block) for Proof of Stake.\rfunc CreateGenesisBlockForPoS(difficulty int) Block {\rtimestamp := time.Now().Unix()\rgenesisBlock := Block{\rIndex: 0,\rTimestamp: timestamp,\rPrevHash: \u0026#34;0\u0026#34;,\rData: \u0026#34;Genesis Block\u0026#34;,\rNonce: 0,\rDifficulty: difficulty,\r}\rgenesisBlock.Hash = CalculateHash(genesisBlock)\rreturn genesisBlock\r} Generating a New Block with Proof of Stake Next, we’ll implement the GenerateNewBlockWithPos function, which generates a new block in the blockchain based on the previous block and the provided data using the Proof of Stake algorithm. Open a new file named pos.go and include the following code: package blockchain\rimport (\r\u0026#34;math/rand\u0026#34;\r\u0026#34;time\u0026#34;\r)\r// GenerateNewBlockWithPoS generates a new block in the blockchain using Proof of Stake.\rfunc GenerateNewBlockWithPoS(prevBlock Block, data string, difficulty int, validators []string) Block {\rtimestamp := time.Now().Unix()\rnewBlock := Block{\rIndex: prevBlock.Index + 1,\rTimestamp: timestamp,\rPrevHash: prevBlock.Hash,\rData: data,\rNonce: 0,\rDifficulty: difficulty,\r}\r// Select a random validator\rrand.Seed(time.Now().UnixNano())\rvalidatorIndex := rand.Intn(len(validators))\rvalidator := validators[validatorIndex]\rnewBlock.Hash = CalculateHashWithValidator(newBlock, validator)\rreturn newBlock\r} Testing and validation: create unit tests to verify that your algorithm is correct. Ensure that the blockchain can be properly synchronized across different nodes.\npackage main\rimport (\r\u0026#34;fmt\u0026#34;\r\u0026#34;github.com/CharlieChen01/BlockchainBasic/blockchain\u0026#34;\r)\rfunc main() {\rdifficulty := 3 // Adjust the difficulty level as needed\r// Test Proof of Work\rpowBlockchain := []blockchain.Block{blockchain.CreateGenesisBlock(difficulty)}\r// Generate a new block with some data using Proof of Work\rnewBlockData := \u0026#34;Block Data\u0026#34;\rnewPowBlock := blockchain.GenerateNewBlockWithPoW(powBlockchain[len(powBlockchain)-1], newBlockData, difficulty)\rpowBlockchain = append(powBlockchain, newPowBlock)\r// Print the Proof of Work blockchain\rfmt.Println(\u0026#34;Proof of Work Blockchain:\u0026#34;)\rfor _, block := range powBlockchain {\rfmt.Printf(\u0026#34;Index: %d\\n\u0026#34;, block.Index)\rfmt.Printf(\u0026#34;Timestamp: %d\\n\u0026#34;, block.Timestamp)\rfmt.Printf(\u0026#34;PrevHash: %s\\n\u0026#34;, block.PrevHash)\rfmt.Printf(\u0026#34;Data: %s\\n\u0026#34;, block.Data)\rfmt.Printf(\u0026#34;Nonce: %d\\n\u0026#34;, block.Nonce)\rfmt.Printf(\u0026#34;Difficulty: %d\\n\u0026#34;, block.Difficulty)\rfmt.Printf(\u0026#34;Hash: %s\\n\\n\u0026#34;, block.Hash)\r}\r// Test Proof of Stake\rposBlockchain := []blockchain.Block{blockchain.CreateGenesisBlockForPoS(difficulty)}\r// Generate a new block with some data using Proof of Stake\rnewPosBlock := blockchain.GenerateNewBlockWithPoS(posBlockchain[len(posBlockchain)-1], newBlockData, difficulty, []string{\u0026#34;Validator 1\u0026#34;, \u0026#34;Validator 2\u0026#34;, \u0026#34;Validator 3\u0026#34;})\rposBlockchain = append(posBlockchain, newPosBlock)\r// Print the Proof of Stake blockchain\rfmt.Println(\u0026#34;Proof of Stake Blockchain:\u0026#34;)\rfor _, block := range posBlockchain {\rfmt.Printf(\u0026#34;Index: %d\\n\u0026#34;, block.Index)\rfmt.Printf(\u0026#34;Timestamp: %d\\n\u0026#34;, block.Timestamp)\rfmt.Printf(\u0026#34;PrevHash: %s\\n\u0026#34;, block.PrevHash)\rfmt.Printf(\u0026#34;Data: %s\\n\u0026#34;, block.Data)\rfmt.Printf(\u0026#34;Nonce: %d\\n\u0026#34;, block.Nonce)\rfmt.Printf(\u0026#34;Difficulty: %d\\n\u0026#34;, block.Difficulty)\rfmt.Printf(\u0026#34;Hash: %s\\n\\n\u0026#34;, block.Hash)\r}\r} ","permalink":"http://localhost:1313/posts/how-to-implement-the-pow-and-pos-algorithms-in-go/","summary":"How to implement Proof of Work (PoW) and Proof of Stake (PoS) algorithms for blockchain in Go? Here are the steps:\nDefine the block structure: Let’s start by creating a new Go project and importing all the necessary packages to build our blockchain. Create a file named blockchain.go and import all the dependencies you need by saving the following code in it. First, you need to define the data structure of the block, including the Index, Timestamp, PrevHash, Data, Nonce, Difficulty, and Hash.","title":"How to Implement the PoW and PoS Algorithms in Go"}]