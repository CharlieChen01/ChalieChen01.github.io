[{"content":"To understand the differences between ERC20 and ERC721, let’s delve into their characteristics:\nFungibility vs. Non-Fungibility:\nERC20 tokens are fungible. This means that each token is identical and interchangeable with any other token of the same type. For example, if you have an ERC20 token representing a cryptocurrency, one unit of that token is equivalent to any other unit of the same token. ERC721 tokens, on the other hand, are non-fungible. Each token is unique and cannot be divided. These tokens represent ownership of specific, individual items. For instance, collectibles, game assets, and real estate can be represented using ERC721 tokens. Functionality:\nERC20 tokens offer basic functions such as transfers and balance checks. They are commonly used for cryptocurrencies, utility tokens, and project ownership. ERC721 tokens provide additional features beyond basic transfers. These features include owner tracking and metadata storage. They are primarily used for representing ownership and trading of unique digital assets. In summary, ERC20 tokens are like money—fungible and interchangeable—while ERC721 tokens are non-fungible and represent unique, indivisible assets. Understanding these differences is crucial when working with Ethereum tokens!\n要了解 ERC20 和 ERC721 的区别，让我们深入了解它们的特点：\n可互换性与不可互换性： ERC20 代币是可互换的。这意味着每个代币都是相同的，可以与任何其他同类型代币互换。例如，如果您有一个代表加密货币的 ERC20 代币，那么该代币的一个单位就等同于相同代币的任何其他单位。 另一方面，ERC721 代币是不可兑换的。每个代币都是独一无二的，不可分割。这些代币代表对特定、个别物品的所有权。例如，收藏品、游戏资产和房地产都可以用 ERC721 代币来表示12。 功能性： ERC20代币提供转账和余额查询等基本功能。它们通常用于加密货币、实用代币和项目所有权。 ERC721代币提供基本转账之外的其他功能。这些功能包括所有者跟踪和元数据存储。它们主要用于代表独特数字资产的所有权和交易。 总之，ERC20 代币就像货币\u0026ndash;可流通、可互换\u0026ndash;而 ERC721 代币不可流通，代表独一无二、不可分割的资产5。在使用以太坊代币时，了解这些差异至关重要！\n","permalink":"http://localhost:1313/posts/differences-between-erc-20-and-erc-721/","summary":"To understand the differences between ERC20 and ERC721, let’s delve into their characteristics:\nFungibility vs. Non-Fungibility:\nERC20 tokens are fungible. This means that each token is identical and interchangeable with any other token of the same type. For example, if you have an ERC20 token representing a cryptocurrency, one unit of that token is equivalent to any other unit of the same token. ERC721 tokens, on the other hand, are non-fungible.","title":"Differences Between ERC 20 and ERC 721"},{"content":"How to implement Proof of Work (PoW) and Proof of Stake (PoS) algorithms for blockchain in Go? Here are the steps: [toc]\nDefine the block structure: Let’s start by creating a new Go project and importing all the necessary packages to build our blockchain. Create a file named blockchain.go and import all the dependencies you need by saving the following code in it. First, you need to define the data structure of the block, including the Index, Timestamp, PrevHash, Data, Nonce, Difficulty, and Hash. The Hash field will store the hash value of the block, while the PrevHash field points to the hash of the previous block in the blockchain.\npackage blockchain\rimport (\r\u0026#34;bytes\u0026#34;\r\u0026#34;crypto/sha256\u0026#34;\r\u0026#34;encoding/hex\u0026#34;\r\u0026#34;strconv\u0026#34;\r\u0026#34;time\u0026#34;\r)\r// Block represents a block in the blockchain.\rtype Block struct {\rIndex int\rTimestamp int64\rPrevHash string\rData string\rNonce int\rDifficulty int\rHash string\r} Create a hash function: The security of the blockchain depends on the hash function. You need to create a function to calculate the hash value of a block, usually using the SHA-256 algorithm.\nfunc calculateHash(block Block) string {\rrecord := strconv.Itoa(block.Index) + strconv.FormatInt(block.Timestamp, 10) +\rblock.PrevHash + block.Data + strconv.Itoa(block.Nonce)\rhash := sha256.Sum256([]byte(record))\rreturn hex.EncodeToString(hash[:])\r} Implement the PoW algorithm: Proof-of-Work algorithms require miners to solve a mathematical puzzle to prove that they put in the work. This usually involves adjusting a block\u0026rsquo;s value until its hash satisfies a specific condition (e.g., starts with a certain number of zeros).\nCreating the POW Genesis Block The genesis block is the first block in the blockchain and serves as the starting point. It has a fixed set of values and does not refer to any previous block. Let’s create a function to generate the genesis block in a file named pow_genesis.go package blockchain\rimport (\r\u0026#34;time\u0026#34;\r)\r// createGenesisBlock creates the first block in the blockchain (genesis block).\rfunc CreateGenesisBlock(difficulty int) Block {\rtimestamp := time.Now().Unix()\rgenesisBlock := Block{\rIndex: 0,\rTimestamp: timestamp,\rPrevHash: \u0026#34;0\u0026#34;,\rData: \u0026#34;Genesis Block\u0026#34;,\rNonce: 0,\rDifficulty: difficulty,\r}\rgenesisBlock.Hash = CalculateHash(genesisBlock)\rreturn genesisBlock\r} The CreateGenesisBlock function generates the genesis block with a given difficulty level. It sets the PrevHash value to \u0026ldquo;0\u0026rdquo; and calculates the hash using the CalculateHash function.\nGenerating a New Block with Proof of Work Next, we’ll implement the GenerateNewBlockWithPoW function, which generates a new block in the blockchain based on the previous block and the provided data using the Proof of Work algorithm. Open a new file named pow.go and include the following code: package blockchain\rimport (\r\u0026#34;math\u0026#34;\r\u0026#34;math/big\u0026#34;\r\u0026#34;time\u0026#34;\r)\r// GenerateNewBlockWithPoW generates a new block in the blockchain using Proof of Work.\rfunc GenerateNewBlockWithPoW(prevBlock Block, data string, difficulty int) Block {\rvar nonce int\rtimestamp := time.Now().Unix()\rnewBlock := Block{\rIndex: prevBlock.Index + 1,\rTimestamp: timestamp,\rPrevHash: prevBlock.Hash,\rData: data,\rNonce: 0,\rDifficulty: difficulty,\r}\r// Perform the proof of work\rtarget := big.NewInt(1)\rtarget.Lsh(target, uint(256-difficulty))\rfor nonce \u0026lt; math.MaxInt64 {\rnewBlock.Nonce = nonce\rhash := CalculateHash(newBlock)\rhashInt := new(big.Int)\rhashInt.SetString(hash, 16)\rif hashInt.Cmp(target) == -1 {\rnewBlock.Hash = hash\rbreak\r} else {\rnonce++\r}\r}\rreturn newBlock\r} The GenerateNewBlockWithPoW function takes the previous block, new data, and the desired difficulty level as parameters. It initializes a new block with the appropriate values and performs the proof of work calculation. The target value represents the threshold that the block\u0026rsquo;s hash must meet to satisfy the difficulty level. The function continues to increment the Nonce until a suitable hash is found.\nImplementing PoS algorithms: Proof-of-Stake algorithms are an alternative consensus mechanism that selects nodes to create new blocks based on the amount of currency a user holds and how long they have held it.\nCreating the Genesis Block package blockchain\rimport (\r\u0026#34;time\u0026#34;\r)\r// CreateGenesisBlockForPoS creates the first block in the blockchain (genesis block) for Proof of Stake.\rfunc CreateGenesisBlockForPoS(difficulty int) Block {\rtimestamp := time.Now().Unix()\rgenesisBlock := Block{\rIndex: 0,\rTimestamp: timestamp,\rPrevHash: \u0026#34;0\u0026#34;,\rData: \u0026#34;Genesis Block\u0026#34;,\rNonce: 0,\rDifficulty: difficulty,\r}\rgenesisBlock.Hash = CalculateHash(genesisBlock)\rreturn genesisBlock\r} Generating a New Block with Proof of Stake Next, we’ll implement the GenerateNewBlockWithPos function, which generates a new block in the blockchain based on the previous block and the provided data using the Proof of Stake algorithm. Open a new file named pos.go and include the following code: package blockchain\rimport (\r\u0026#34;math/rand\u0026#34;\r\u0026#34;time\u0026#34;\r)\r// GenerateNewBlockWithPoS generates a new block in the blockchain using Proof of Stake.\rfunc GenerateNewBlockWithPoS(prevBlock Block, data string, difficulty int, validators []string) Block {\rtimestamp := time.Now().Unix()\rnewBlock := Block{\rIndex: prevBlock.Index + 1,\rTimestamp: timestamp,\rPrevHash: prevBlock.Hash,\rData: data,\rNonce: 0,\rDifficulty: difficulty,\r}\r// Select a random validator\rrand.Seed(time.Now().UnixNano())\rvalidatorIndex := rand.Intn(len(validators))\rvalidator := validators[validatorIndex]\rnewBlock.Hash = CalculateHashWithValidator(newBlock, validator)\rreturn newBlock\r} Testing and validation: create unit tests to verify that your algorithm is correct. Ensure that the blockchain can be properly synchronized across different nodes.\npackage main\rimport (\r\u0026#34;fmt\u0026#34;\r\u0026#34;github.com/CharlieChen01/BlockchainBasic/blockchain\u0026#34;\r)\rfunc main() {\rdifficulty := 3 // Adjust the difficulty level as needed\r// Test Proof of Work\rpowBlockchain := []blockchain.Block{blockchain.CreateGenesisBlock(difficulty)}\r// Generate a new block with some data using Proof of Work\rnewBlockData := \u0026#34;Block Data\u0026#34;\rnewPowBlock := blockchain.GenerateNewBlockWithPoW(powBlockchain[len(powBlockchain)-1], newBlockData, difficulty)\rpowBlockchain = append(powBlockchain, newPowBlock)\r// Print the Proof of Work blockchain\rfmt.Println(\u0026#34;Proof of Work Blockchain:\u0026#34;)\rfor _, block := range powBlockchain {\rfmt.Printf(\u0026#34;Index: %d\\n\u0026#34;, block.Index)\rfmt.Printf(\u0026#34;Timestamp: %d\\n\u0026#34;, block.Timestamp)\rfmt.Printf(\u0026#34;PrevHash: %s\\n\u0026#34;, block.PrevHash)\rfmt.Printf(\u0026#34;Data: %s\\n\u0026#34;, block.Data)\rfmt.Printf(\u0026#34;Nonce: %d\\n\u0026#34;, block.Nonce)\rfmt.Printf(\u0026#34;Difficulty: %d\\n\u0026#34;, block.Difficulty)\rfmt.Printf(\u0026#34;Hash: %s\\n\\n\u0026#34;, block.Hash)\r}\r// Test Proof of Stake\rposBlockchain := []blockchain.Block{blockchain.CreateGenesisBlockForPoS(difficulty)}\r// Generate a new block with some data using Proof of Stake\rnewPosBlock := blockchain.GenerateNewBlockWithPoS(posBlockchain[len(posBlockchain)-1], newBlockData, difficulty, []string{\u0026#34;Validator 1\u0026#34;, \u0026#34;Validator 2\u0026#34;, \u0026#34;Validator 3\u0026#34;})\rposBlockchain = append(posBlockchain, newPosBlock)\r// Print the Proof of Stake blockchain\rfmt.Println(\u0026#34;Proof of Stake Blockchain:\u0026#34;)\rfor _, block := range posBlockchain {\rfmt.Printf(\u0026#34;Index: %d\\n\u0026#34;, block.Index)\rfmt.Printf(\u0026#34;Timestamp: %d\\n\u0026#34;, block.Timestamp)\rfmt.Printf(\u0026#34;PrevHash: %s\\n\u0026#34;, block.PrevHash)\rfmt.Printf(\u0026#34;Data: %s\\n\u0026#34;, block.Data)\rfmt.Printf(\u0026#34;Nonce: %d\\n\u0026#34;, block.Nonce)\rfmt.Printf(\u0026#34;Difficulty: %d\\n\u0026#34;, block.Difficulty)\rfmt.Printf(\u0026#34;Hash: %s\\n\\n\u0026#34;, block.Hash)\r}\r} ","permalink":"http://localhost:1313/posts/how-to-implement-the-pow-and-pos-algorithms-in-go/","summary":"How to implement Proof of Work (PoW) and Proof of Stake (PoS) algorithms for blockchain in Go? Here are the steps: [toc]\nDefine the block structure: Let’s start by creating a new Go project and importing all the necessary packages to build our blockchain. Create a file named blockchain.go and import all the dependencies you need by saving the following code in it. First, you need to define the data structure of the block, including the Index, Timestamp, PrevHash, Data, Nonce, Difficulty, and Hash.","title":"How to Implement the POW and POS Algorithms in Go"}]